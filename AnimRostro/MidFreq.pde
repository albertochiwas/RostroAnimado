/**
  * This sketch demonstrates how to use an FFT to analyze
  * the audio being generated by an AudioPlayer.
  * FFT stands for Fast Fourier Transform, which is a 
  * method of analyzing audio that allows you to visualize 
  * the frequency content of a signal. You've seen 
  * visualizations like this before in music players 
  * and car stereos.
  
  http://code.compartmental.net/minim/
  http://code.compartmental.net/minim/index_analysis.html
  
  https://en.wikipedia.org/wiki/Range_(music)
  
  Hombre adulto [360]
         bajo    90  -  330   (220)
     baritono   110  -  440   (320)
        tenor   140  -  500   (420)
  Mujer adulta  [500] Niño/Niña [520/560]
         alto   160  -  620   (520)
mezzo-soprano   220  -  800   (660)
      soprano   260  - 1100   (790)
  */

import ddf.minim.analysis.*; // FFT
//import ddf.minim.effects.*; // BandPass
import ddf.minim.*;

//Minim  minim = null;

final int fCent = 320; // 320 SET HERE CENTRAL FREQ (USER VOICE PITCH)
final int fMin = fCent - 120; // 210
final int fMax = fCent + 200; // 450
final int TOP = 5; // No. Freq Candidato con mayor nivel
final float LowestValue = 8.5; // Lowest energy cutoff
final float MinEnergy = 120.0; // Min. Energy (suma)


class MidFreq
{
  FFT         fft;
  AudioInput  mic;

 public MidFreq() {
   if ( minim == null ) { // Lazy init
      minim = new Minim(this);
   }
   mic = minim.getLineIn();
   fft = new FFT( mic.bufferSize(), mic.sampleRate() );  
 }
 
 public PVector getFreq() { // return: x=prom freq, y=energia total, z=freq +intensa @muestra=TOP=5 freq +altas
    fft.forward( mic.mix );
    IntDict DBMax = new IntDict();
    for (int i=0; i < fft.specSize(); i++) { //2
      float value = fft.getBand(i); 
      line( i, height, i, height - value*8 );
      if ( value >= LowestValue ) { //3
        int freq = round(fft.indexToFreq(i));
        if ( freq>fMin && freq<fMax ) { //4
          int v = round(value);
          DBMax.set(str(freq),v); // key=freq, value=energy
        } //4
      } //3
    } //2
    DBMax.sortValuesReverse();  // mayor a menor intensidad
    int i = 0;
    float suma = 0.0;
    float mv[] = new float[TOP]; // energy
    float mf[] = new float[TOP]; // freq
    float high = 0.0;
    for (String k : DBMax.keys()) { //2 key=freq  value=volume
      int value = DBMax.get(k);
      if (i==0) {
        high = value;
      }
      if (i < TOP) { //3
        suma += float(value);
        mf[i] = float(k);
        mv[i] = float(value);
//        println(i+") "+k+"="+value);
      } //3
      ++i;
      if (i >= TOP) { //3 cinco intensidades mas grandes
        if (suma < MinEnergy) { //4 Noise threshold
          return new PVector(0,suma,high); // (freq,energy,hi-energy freq)
        } //4
        float fm = 0.0;
        for (int j=0; j<TOP; j++) { //4
            fm += (mf[j] * mv[j]/suma);
        } //4
        return new PVector(fm,suma,high); //2 // (central-freq,energy,hi-energy freq)
      } //3 if
    } //2 for
    return new PVector(0,suma,high); // (freq,energy,hi-energy freq)
 } //1

 public void stop() {
    if ( minim != null ) {
      minim.stop();
    }
 }
 
} // class
